# Collective cheatsheet

## Hypotese

En null hypotese kan konkluderes afvist hvis en eller flere af nedstående tilgælde gælder:

1.  p-værdi er under alpha (eller nogen gange bare 0.1)
2.  test-statistik (t_obs) er ude af confidensintervallet. (critical value)
3.  confidensintervallet ikke indeholder den hypotetiske værdi.

## Binominal:

```{r}
numberOfItems <- 2
success <- 0
prob <- 0.5

#Calculate the probability of x sucsess, when pulling n numberOfItems
#where the probability of sucsess is prob.

#Beregn sandsynligheden for x succeser, når der vælges n antal ting
#Og sandsynligheden for en succses er prob.

pbinom(success,numberOfItems,prob)
```

## Hyper

Probability

```{r}
Type1Drawn <- 1
Type1All <- 2
Type2All <- 2
AllDrawn <- 2

#The probability of having drawn x Type1Drawn, in a draw of n AllDrawn.
#Where there are x of Type1All and x of Type2All to choose from.

dhyper(x=Type1Drawn, m=Type1All, n=Type2All, k=AllDrawn)

```

Variance

```{r}

#Calculate the variance given a probability (p) and number of participants (n)
n <- 25
p <- 0.8

#variance
n*p*(1-p)

```

## Poisson

## Proportion

Often uses Chi Squared for hyp-test

Prop.test

```{r}
#hmm needs explaining...
prop.test(x=c(171, 47), n=c(4675+171, 2040+47), correct=FALSE, conf.level=0.95)
```

Expected number of x in sample y, under null hyp (no change)

```{r}
SumOfX <- 80
SumOfSample <- 2088

SumOfAll <- 12129


# expected 
(SumOfX*SumOfSample)/SumOfAll



```

Calculate P-value (pvalue) for Chi squared

```{r}
tobs <- 132.3
degreeFreedom <- 6


#p value
1 - pchisq(tobs, df=degreeFreedom)

```

## Chi Squared

Degree of Freedom

```{r}
NumberOfRows <- 4
NumberOfColumns <- 3

degreeFreedom <- (NumberOfRows-1)*(NumberOfColumns-1)
degreeFreedom
```

Calculate P-value (pvalue) for Chi squared

```{r}
tobs <- 132.3
degreeFreedom <- 6


#p value
1 - pchisq(tobs, df=degreeFreedom)

```

```{r}
NumberOfRows <- 4
NumberOfColumns <- 3

degreeFreedom <- (NumberOfRows-1)*(NumberOfColumns-1)
degreeFreedom


#enter as columns
M <- as.table(cbind(c(4675,2222,2750,2040),c(171,95,49,47),c(76,1,2,1)))
M

chisq.test(M)

```

## One way Anova

## Two way Anova
Find the expected value of group1 at treat n

```{r}
#expected value of group1 at treat n
OverallAverage <- 0.523
TreatAverage <- 0.640
GroupAverage <- 0.479


#Expected
OverallAverage+(TreatAverage-OverallAverage)+(GroupAverage-OverallAverage)

```


Confidence interval, for the difference in mean valuw from group1 and group2
pre-planned 95% confidence interval
```{r}
TotalNumberOfSamples <- 16
NumberOfTreat <- 8
mean1 <- 0.479
mean2 <- 0.568
sd1 <- 0.077
sd2 <- 0.155

SSTr <- 0.179194
SSE <- 0.030644

MSTr <-  0.0255991
MSE <-  0.0043777

#Calculate qt
numberOfItems <- 1
degreeFreedom <- NumberOfTreat - numberOfItems
degreeFreedom
qt <- qt(0.975,degreeFreedom)
qt

#confidence interval
(mean1 - mean2) + c(-1,1)*qt *sqrt(MSE*2/NumberOfTreat)

```

pvalue, given a data set

```{r}
tab <- data.frame(clo=c(0.52,0.53,0.54,0.53,0.50,0.46,0.44,0.31,
0.76,0.71,0.68,0.64,0.50,0.51,0.43,0.31))
tab$temp <- as.factor(c(1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8))

anova(lm(clo ~temp,data=tab))


```






## Exponential

## Simulation af sandsynlighed

Givet en normalfordeling, hvad er sandsynligheden for at et tal er over x?

Fks givet:\
mean = 20, sd= 5

Hvad er sansynligheden for at et givet tal er over 25?

Dette kan gøres med simulation hvis man ikke kan huske formlen

```{r}
n <- 10000
data <- rnorm(n,mean=20, sd=5)
stor = function(x) {
  x > 25
}
sum(sapply(data,stor)) / n

```

Her er stor en funktion som returnerer en boolean om tallet er større end 25. Ved at summe dem alle op tæller man hvor mange der er sande. Sandsynligheden er derfor antal sande / antal.

### Sum af sandsynlighed

Hvis der skal tages summen af to sandsynligheder, hvor de er normalfordelt kan man bare udregne den nye normalfordeling.

Givet en normalfordelint X og Y hvor:

X = N(20,5²)\
Y = N(50,10²)

Kan den nye normalfordeling hvor der er 1. af hver være:

NY = N(20+50, sqrt(5² + 10²)²)

NY = N(70,sqrt(125)²)

### Confidensintervaller i simulation

Hvis der skal findes et confidensinterval i simulationen kan det findes ved

```{r}
quantile(sort(data),c(0.025,0.975))
```

Hvor der i eksemplet bliver brugt alpha=0.05.

## Normal

Calculate standard deviation

```{r}
#Given mean and a percentage within a range
Mean <- 100
Percentage <- 68
rangeLower <- 85
rangeUpper <- 115

## The quantile at range Lower
lowerQuan <- Mean/2-Percentage/2

## The lower quantile in the std. norm.
Z <- qnorm(lowerQuan/100)

#calculate Standard Deviation
sd <- (rangeLower-Mean)/Z
sd
```

Percentage of items above a value x

```{r}
#Given mean and sd

mean <- 100
sd <- 15

#percent of items above x
x <- 140
1 - pnorm(x, mean=mean, sd=sd)




#Given mean and a percentage within a range
Mean <- 100
Percentage <- 68
rangeLower <- 85
rangeUpper <- 115

## The quantile at range Lower
lowerQuan <- Mean/2-Percentage/2
lowerQuan
## The quantile at range upper
upperQuan <- Mean/2+Percentage/2
upperQuan

## The lower quantile in the std. norm.
Z <- qnorm(lowerQuan/100)


#calculate Standard Deviation
sd <- (rangeLower-Mean)/Z

#percent of items above x
x <- 140
1 - pnorm(x, mean=mean, sd=sd)


```

## Confidence interval

Mean

```{r}
lower <- 2.26
upper <- 5.26
  
#Calculate the mean from a lower and an upper bound of a confidence interval of the mean
(lower+upper)/2
#Note you cannot know the sample mean from simulated data

```

Calculate confidence interval

```{r}
n <- 16
mean <- 0.5
sd <- 0
standardError <- 0.0043777

#Calculate qt
numberOfItems <- 2
degreeFreedom <- n-numberOfItems
qt <- qt(0.975,degreeFreedom)
qt
#confidence interval
mean + c(-1,1)* qt * sd/sqrt(n)
mean + c(-1,1)* qt * standardError


#Given qt 
qt <- 0

mean + c(-1,1)* qt * sd/sqrt(n)
mean + c(-1,1)* qt * standardError

```

Confidence interval for mean on a data set

```{r}
#given a data set
x <- c(10.5, 9.3, 10.7, 10.8, 11.2)

# remember the %
alpha <- 0.1
percent <- (1-alpha/2)
qt <- qt(percent,length(x)-1)
mean(x) + c(-1,1)* qt * sd(x)/sqrt(length(x))

#or use t.test remember the conf-level
t.test(x,conf.level=0.9)

```

## Linear Simulation

Variance

```{r}
#Simulate to get variance, normal distribution
#given 2*Y + 2*X + 4

k <- 800000

MeanX <- 10
SdX <- sqrt(4)

MeanY <- 20
SdY <- sqrt(25)

X <- rnorm(k,MeanX,SdX)
Y <- rnorm(k,MeanY,SdY)

z <- 2* Y + 2*X +4

var(z)
```

Standard Divination

```{r}
#Simulate to get Standard Divination, normal distribution
#given 2*Y^2 + X^3/3

k <- 800000

MeanX <- 10
SdX <- sqrt(4)

MeanY <- 20
SdY <- sqrt(25)

X <- rnorm(k,MeanX,SdX)
Y <- rnorm(k,MeanY,SdY)

z <- 2*Y^2 + X^3/3

sd(z)
```

## test statistic

Calculate tobs

```{r}
#Given n number of samples
#Given the actual mean or something similar
#Compared to the expected mean or something similar

n <- 20
actual <- 0
expected <- 0

# given standard deviation
sd <- -1
#beregn t_obs (tobs)
(actual - expected)/(sd/sqrt(n))



# given standard error
standardError <- 5.867*10^4
#beregn t_obs (tobs)
(actual - expected)/(standardError)



```

Calculate tobs given two data sets

```{r}
#given a two data sets x and y
x <- c(10.5, 9.3, 10.7, 10.8, 11.2)
y <- c(8.9, 9.5, 10.2, 9.8, 10.3)

t.test(x,y)
#find: t = ...
```

tobs on a certain p-value

```{r}
NumberOfSamples <- 20
degreeFreedom <- NumberOfSamples-1
pValue <- 0.001

qt(1-pValue/2,degreeFreedom)
qt(pValue/2,degreeFreedom)


```

### Power t.test

Two sample

```{r}
#pooled variance
x <- c(10.5, 9.3, 10.7, 10.8, 11.2)
y <- c(8.9, 9.5, 10.2, 9.8, 10.3)
n1 <- length(x)
n2 <- length(y)
VarPooled <- ((n1-1)*var(x)+(n2-1)*var(y)) / (n1+n2-2)

#minimum number of observations / samples
power.t.test(delta=1,sd = sqrt(VarPooled),sig.level = 0.01,power=0.99)




```

One sample

GIvet en power, afvigelse fra mean, sd og signifikantniveau kan den nødvendige n findes ved:

```{r}

power.t.test(power = 0.9, delta = 0.05, sd = 0.11,
sig.level = 0.01, type = "one.sample")

```

### Fobs

```{r}
k <- 8; n <- 0 # Number of treatments k, total number of observations n

SSTr <- 0.179194
SSE <-  0.030644

MSTr <- 0.0315062
MSE <-  0.0043777

degreeFreedomTreatment <- k - 1
print("Degree of freedom:")
degreeFreedomTreatment


Fobs <- (MSTr / MSE)
print("Fobs")
Fobs


Fobs <- (SSTr/(k-1)) / (SSE/(n-k))
print("Fobs")
Fobs

```

## Linear Model:

I en linear model af

```{r}
lm(X ~ Y)
```

Gælder det at: X er dependent variable Y er explanatory variable

Beta_0 er (Intecept) estimate Beta_1 er Y estimate sigma er residual standard error.

Predictions ved x_0 udregnes som:

```{r}
sxx <- (n-1) * var(Y)
t_alpha <- qt(0.95, df=n-2) #alpha = 0.9
beta_0 + beta_1 * x_0 + c(-1,1) * t_alpha * res_err * sqrt(1+1/n + (x_0-mean(x)/ sxx))
```
